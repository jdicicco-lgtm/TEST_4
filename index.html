<script>
  // =========================
  // CONFIG & GLOBAL STATE
  // =========================
  const VEHICLE_GROUPS = [
    "Commercial Van",
    "Large",
    "Economy",
    "Small",
    "Mini",
    "Premium",
    "Suv",
    "People Mover",
    "Station Wagon",
    "Cabriolet"
  ];

  // Mappa tutti i codici possibili â†’ 10 gruppi canonici
const RAW_GROUP_MAP = {
  "COMMERCIAL VAN": "Commercial Van",
  "COMM VAN": "Commercial Van",
  "COMMERCIALVAN": "Commercial Van",
  "COMMERCIAL PEOPLE MOVER": "Commercial Van",   // ðŸ‘ˆ CAMBIATO: ora mappa su Commercial Van

  "LARGE": "Large",

  "ECONOMY": "Economy",

  "SMALL": "Small",

  "MINI": "Mini",

  "PREMIUM": "Premium",

  "SUV": "Suv",

  "PEOPLE MOVER": "People Mover",               // ðŸ‘ˆ resta distinto
  "PEOPLEMOVER": "People Mover",

  "STATION": "Station Wagon",
  "STATION WAGON": "Station Wagon",

  "CABRIOLET": "Cabriolet",
  "CABRIO": "Cabriolet"
};


  function canonicalGroup(raw) {
    if (raw === null || raw === undefined) return null;
    let s = String(raw).trim();
    if (!s || s.toLowerCase() === "nan") return null;

    const up = s.toUpperCase();
    if (RAW_GROUP_MAP[up]) return RAW_GROUP_MAP[up];

    // se arriva giÃ  nei 10 gruppi canonici (es. da fleetStations2025)
    if (VEHICLE_GROUPS.includes(s)) return s;

    return null;
  }

  const MONTH_LABELS_IT = [
    "Gennaio",
    "Febbraio",
    "Marzo",
    "Aprile",
    "Maggio",
    "Giugno",
    "Luglio",
    "Agosto",
    "Settembre",
    "Ottobre",
    "Novembre",
    "Dicembre"
  ];

  let fleetData = [];
  let fleetStationsData = [];
  let bookingsData = [];

  // baseAggregates = tutti i mesi 2024â€“2026 con filtri gruppo/acquisizione/stazione + proiezioni
  let baseAggregates = [];
  // monthlyAggregates = baseAggregates filtrata per anni/mesi selezionati (grafico + export)
  let monthlyAggregates = [];
  let mainChart = null;

  // =========================
  // INIT
  // =========================
  document.addEventListener("DOMContentLoaded", () => {
    initMonthsFilter();
    initGroupFilter();
    loadData().then(() => {
      initAcquisitionFilter();
      initStationFilter();
      initFilterEvents();
      applyFiltersAndRender();
    });

    document.getElementById("clearFiltersBtn").addEventListener("click", resetFilters);
    document.getElementById("exportCsvBtn").addEventListener("click", exportCsv);
    document.getElementById("printPdfBtn").addEventListener("click", () => window.print());
  });

  // =========================
  // DATA LOADING
  // =========================
  async function loadData() {
    try {
      const [fleetRes, fleetStationsRes, bookingsRes] = await Promise.all([
        fetch("fleetData_clean.json"),
        fetch("fleetStations2025.json"),
        fetch("bookings2025.json")
      ]);

      fleetData = await fleetRes.json();
      fleetStationsData = await fleetStationsRes.json();
      bookingsData = await bookingsRes.json();
    } catch (err) {
      console.error("Errore nel caricamento dei JSON:", err);
      alert("Errore nel caricamento dei dati. Controlla i file JSON nella root del repo.");
    }
  }

  // =========================
  // FILTER INIT
  // =========================
  function initMonthsFilter() {
    const monthSelect = document.getElementById("monthFilter");
    MONTH_LABELS_IT.forEach((label, idx) => {
      const opt = document.createElement("option");
      opt.value = String(idx + 1).padStart(2, "0");
      opt.textContent = label;
      monthSelect.appendChild(opt);
    });
  }

  function initGroupFilter() {
    const groupSelect = document.getElementById("groupFilter");
    VEHICLE_GROUPS.forEach(g => {
      const opt = document.createElement("option");
      opt.value = g;
      opt.textContent = g;
      groupSelect.appendChild(opt);
    });
  }

  function initAcquisitionFilter() {
    const acquisitionSelect = document.getElementById("acquisitionFilter");
    const set = new Set();
    fleetData.forEach(row => {
      const val = row["ACQUISIZIONE"];
      if (val !== null && val !== undefined && String(val).trim() !== "") {
        set.add(String(val).trim());
      }
    });
    // anche dal booking, cosÃ¬ i valori combaciano
    bookingsData.forEach(row => {
      const val = row["acquisizione"];
      if (val !== null && val !== undefined && String(val).trim() !== "") {
        set.add(String(val).trim());
      }
    });

    Array.from(set).sort().forEach(a => {
      const opt = document.createElement("option");
      opt.value = a;
      opt.textContent = a;
      acquisitionSelect.appendChild(opt);
    });
  }

  function normalizeStationName(name) {
    if (name === null || name === undefined) return null;
    const lower = String(name).trim().toLowerCase();
    if (!lower) return null;
    return lower.charAt(0).toUpperCase() + lower.slice(1);
  }

  function initStationFilter() {
    const stationSelect = document.getElementById("stationFilter");
    const set = new Set();

    // da fleetStations2025
    fleetStationsData.forEach(row => {
      const raw = row["station"];
      const norm = normalizeStationName(raw);
      if (norm) set.add(norm);
    });

    // da bookings2025
    bookingsData.forEach(row => {
      const raw = row["stazione"];
      const norm = normalizeStationName(raw);
      if (norm) set.add(norm);
    });

    Array.from(set)
      .sort()
      .forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        stationSelect.appendChild(opt);
      });
  }

  function initFilterEvents() {
    const filterIds = [
      "yearFilter",
      "monthFilter",
      "groupFilter",
      "acquisitionFilter",
      "stationFilter",
      "projectionSelect"
    ];
    filterIds.forEach(id => {
      document.getElementById(id).addEventListener("change", applyFiltersAndRender);
    });
  }

  function getMultiSelectValues(selectId) {
    const select = document.getElementById(selectId);
    return Array.from(select.selectedOptions).map(o => o.value);
  }

  function resetFilters() {
    ["yearFilter", "monthFilter", "groupFilter", "acquisitionFilter", "stationFilter"].forEach(id => {
      const select = document.getElementById(id);
      Array.from(select.options).forEach(opt => (opt.selected = false));
    });
    document.getElementById("projectionSelect").value = "0.10";
    applyFiltersAndRender();
  }

  // =========================
  // DATE HELPERS
  // =========================
  function parseDate(value) {
    if (value === null || value === undefined) return null;

    // numero: epoch ms
    if (typeof value === "number") {
      const d = new Date(value);
      return isNaN(d.getTime()) ? null : d;
    }

    let str = String(value).trim();
    if (!str) return null;

    // solo cifre â†’ epoch ms
    if (/^\d+$/.test(str)) {
      const ms = parseInt(str, 10);
      const d = new Date(ms);
      return isNaN(d.getTime()) ? null : d;
    }

    // ISO-like yyyy-mm-dd
    if (/^\d{4}-\d{2}-\d{2}/.test(str)) {
      const d = new Date(str);
      return isNaN(d.getTime()) ? null : d;
    }

    // dd/mm/yyyy
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(str)) {
      const [dStr, mStr, yStr] = str.split("/");
      const d = new Date(parseInt(yStr, 10), parseInt(mStr, 10) - 1, parseInt(dStr, 10));
      return isNaN(d.getTime()) ? null : d;
    }

    const d = new Date(str);
    return isNaN(d.getTime()) ? null : d;
  }

  function formatYearMonthKey(year, month) {
    return year + "-" + String(month).padStart(2, "0");
  }

  function getMonthIndexGlobal(year, month) {
    // 2024-01 â†’ 0, ... 2026-12 â†’ 35
    return (year - 2024) * 12 + (month - 1);
  }

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  // =========================
  // CORE: APPLY FILTERS
  // =========================
  function applyFiltersAndRender() {
    const selectedYears = getMultiSelectValues("yearFilter").map(v => parseInt(v, 10));
    const selectedMonths = getMultiSelectValues("monthFilter").map(v => parseInt(v, 10));
    const selectedGroups = getMultiSelectValues("groupFilter");
    const selectedAcquisition = getMultiSelectValues("acquisitionFilter");
    const selectedStations = getMultiSelectValues("stationFilter");
    const projectionFactor = parseFloat(document.getElementById("projectionSelect").value || "0.10");

    // 1) Aggregazione base su TUTTI i mesi 2024â€“2026
    baseAggregates = computeMonthlyAggregatesBase({
      groups: selectedGroups,
      acquisitions: selectedAcquisition,
      stations: selectedStations,
      projectionFactor
    });

    // 2) Selezione mese/anno per grafico e export
    monthlyAggregates = baseAggregates.filter(b => {
      const yearOk = selectedYears.length === 0 || selectedYears.includes(b.year);
      const monthOk = selectedMonths.length === 0 || selectedMonths.includes(b.month);
      return yearOk && monthOk;
    });

    updateKpiCards();
    updateChart();
  }

  // =========================
  // AGGREGATION LOGIC (BASE)
  // =========================
  function computeMonthlyAggregatesBase(filters) {
    const { groups, acquisitions, stations, projectionFactor } = filters;

    const monthlyMap = new Map();
    for (let year = 2024; year <= 2026; year++) {
      for (let month = 1; month <= 12; month++) {
        const key = formatYearMonthKey(year, month);
        monthlyMap.set(key, {
          year,
          month,
          key,
          label: MONTH_LABELS_IT[month - 1].slice(0, 3) + " " + year,
          fleetSize: 0,
          canoneImponibile: 0,
          canoneIvato: 0,
          assicurazione: 0,
          costoTotale: 0,
          revenue: 0,
          revenueDays: 0,
          revenuePerDay: 0,
          numBookings: 0,
          noleggiati: 0
        });
      }
    }
    
// =========================
// STATION FILTER (FLOTTA) PER ANNO/MESE via fleetStations2025
// =========================
function applyStationFilterToFleet(monthlyMap, groups, stations) {
  if (!fleetStationsData || fleetStationsData.length === 0) return;
  if (!stations || stations.length === 0) return;

  // costruiamo una mappa: key = "YYYY-MM" -> { all, selected }
  const monthStats = new Map();

  fleetStationsData.forEach(row => {
    const gruppoCanonico = canonicalGroup(row["group"]);
    if (!gruppoCanonico) return;
    if (groups.length > 0 && !groups.includes(gruppoCanonico)) return;

    const rawStation = row["station"];
    const stationNorm = normalizeStationName(rawStation);
    if (!stationNorm) return;

    const year = parseInt(row["year"], 10);
    const month = parseInt(row["month"], 10);
    if (!year || !month) return;

    const key = formatYearMonthKey(year, month);
    const fleetCount =
      parseFloat(String(row["fleet"] ?? 0).replace(",", ".")) || 0;

    if (!monthStats.has(key)) {
      monthStats.set(key, { all: 0, selected: 0 });
    }
    const stats = monthStats.get(key);
    stats.all += fleetCount;
    if (stations.includes(stationNorm)) {
      stats.selected += fleetCount;
    }
  });

  // Applichiamo il fattore mese per mese alla flotta e ai costi
  monthlyMap.forEach((bucket, key) => {
    const stats = monthStats.get(key);
    if (!stats || stats.all <= 0 || stats.selected <= 0) return;

    const factor = stats.selected / stats.all;
    if (!isFinite(factor) || factor <= 0) return;

    bucket.fleetSize *= factor;
    bucket.canoneImponibile *= factor;
    bucket.canoneIvato *= factor;
    bucket.assicurazione *= factor;
    bucket.costoTotale *= factor;
  });
}

    // ---- 1) Flotta (fleetData_clean) -> chiave GRUPPO ----
    fleetData.forEach(row => {
      const gruppoCanonico = canonicalGroup(row["GRUPPO"]);
      if (!gruppoCanonico) return;
      if (groups.length > 0 && !groups.includes(gruppoCanonico)) return;

      const acquisizione = row["ACQUISIZIONE"];
      if (
        acquisitions.length > 0 &&
        (!acquisizione || !acquisitions.includes(String(acquisizione).trim()))
      ) {
        return;
      }

      const start = parseDate(row["DATA INIZIO"]);
      const effectiveEnd = parseDate(row["RICONSEGNA EFFETTIVA"]);
      const plannedEnd = parseDate(row["DATA FINE"]);

      const startDate = start;
      const endDate = effectiveEnd || plannedEnd;
      if (!startDate || !endDate) return;
      if (endDate < startDate) return;

      const canoneImp =
        parseFloat(String(row["CANONE IMPONIBILE"] ?? "0").replace(",", ".")) || 0;
      const canoneIvato =
        parseFloat(String(row["CANONE IVATO"] ?? "0").replace(",", ".")) || 0;
      const coperturaAss =
        parseFloat(String(row["COPERTURA ASS."] ?? "0").replace(",", ".")) || 0;

      const startYear = Math.max(2024, startDate.getFullYear());
      const endYear = Math.min(2026, endDate.getFullYear());

      for (let year = startYear; year <= endYear; year++) {
        const monthStart =
          year === startDate.getFullYear() ? startDate.getMonth() + 1 : 1;
        const monthEnd =
          year === endDate.getFullYear() ? endDate.getMonth() + 1 : 12;

        for (let month = monthStart; month <= monthEnd; month++) {
          const key = formatYearMonthKey(year, month);
          const bucket = monthlyMap.get(key);
          if (!bucket) continue;

          bucket.fleetSize += 1;
          bucket.canoneImponibile += canoneImp;
          bucket.canoneIvato += canoneIvato;
          bucket.assicurazione += coperturaAss;
          bucket.costoTotale += canoneImp + coperturaAss;
        }
      }
    });

    // ---- 2) Filtro stazione sulla flotta tramite fleetStations2025 (chiave group) ----
   // ---- 2) Filtro stazione sulla flotta tramite fleetStations2025 (per anno/mese/gruppo) ----
applyStationFilterToFleet(monthlyMap, groups, stations);

    // ---- 3) Prenotazioni (bookings2025) -> chiave gruppo/cartype ----
    bookingsData.forEach(row => {
      const gruppoCanonico = canonicalGroup(row["cartype"] ?? row["gruppo"]);
      if (!gruppoCanonico) return;
      if (groups.length > 0 && !groups.includes(gruppoCanonico)) return;

      const rawStation = row["stazione"];
      const stationNorm = normalizeStationName(rawStation);
      if (stations.length > 0 && (!stationNorm || !stations.includes(stationNorm))) {
        return;
      }

      const acquisizioneBooking = row["acquisizione"];
      if (
        acquisitions.length > 0 &&
        (!acquisizioneBooking ||
          !acquisitions.includes(String(acquisizioneBooking).trim()))
      ) {
        return;
      }

      const fromDate = parseDate(row["startDate"]);
      if (!fromDate) return;

      let days = parseFloat(row["duration"] ?? 0);
      if (!isFinite(days)) days = 0;
      if (days < 1) days = 1;

      const revenue =
        parseFloat(String(row["price"] ?? "0").replace(",", ".")) || 0;

      const year = fromDate.getFullYear();
      const month = fromDate.getMonth() + 1;
      if (year < 2024 || year > 2026) return;

      const key = formatYearMonthKey(year, month);
      const bucket = monthlyMap.get(key);
      if (!bucket) return;

      bucket.revenue += revenue;
      bucket.revenueDays += days;
      bucket.numBookings += 1;
    });

    // Calcolo revenue/day e noleggiati
    monthlyMap.forEach(bucket => {
      if (bucket.revenueDays > 0) {
        bucket.revenuePerDay = bucket.revenue / bucket.revenueDays;
      } else {
        bucket.revenuePerDay = 0;
      }

      const fleetAvailable = bucket.fleetSize;
      if (fleetAvailable > 0 && bucket.revenueDays > 0) {
        const utilization = bucket.revenueDays / (fleetAvailable * 30);
        bucket.noleggiati = utilization * fleetAvailable;
      } else {
        bucket.noleggiati = 0;
      }
    });

    // ---- 4) Proiezioni 2026 ----
    if (!isNaN(projectionFactor) && projectionFactor !== 0) {
      monthlyMap.forEach(bucket => {
        if (bucket.year === 2026) {
          const factor = 1 + projectionFactor;
          bucket.fleetSize *= factor;
          bucket.canoneImponibile *= factor;
          bucket.canoneIvato *= factor;
          bucket.assicurazione *= factor;
          bucket.costoTotale *= factor;
          bucket.revenue *= factor;
          bucket.revenuePerDay *= factor;
          bucket.numBookings *= factor;
          bucket.noleggiati *= factor;
        }
      });
    }

    const result = Array.from(monthlyMap.values()).sort((a, b) => {
      const ia = getMonthIndexGlobal(a.year, a.month);
      const ib = getMonthIndexGlobal(b.year, b.month);
      return ia - ib;
    });

    return result;
  }

  // =========================
  // STATION FACTOR (FLOTTA) via fleetStations2025 (chiave group)
  // =========================
  
  // =========================
  // KPI CALCULATION (current + previous)
  // =========================
  function updateKpiCards() {
    if (!monthlyAggregates || monthlyAggregates.length === 0) {
      resetKpiDisplay();
      return;
    }

    // Range corrente = mesi effettivamente selezionati (dopo filtro anno/mese)
    const indicesCurrent = monthlyAggregates.map(b =>
      getMonthIndexGlobal(b.year, b.month)
    );
    const minIdx = Math.min(...indicesCurrent);
    const maxIdx = Math.max(...indicesCurrent);
    const lengthRange = maxIdx - minIdx + 1;

    // Range precedente: stesso numero di mesi spostato indietro
    const prevEnd = minIdx - 1;
    const prevStart = prevEnd - (lengthRange - 1);

    const prevStartClamped = clamp(prevStart, 0, 35);
    const prevEndClamped = clamp(prevEnd, 0, 35);

    function sumForIndices(indicesSet) {
      const res = {
        fleetSize: 0,
        canoneImponibile: 0,
        canoneIvato: 0,
        assicurazione: 0,
        costoTotale: 0,
        revenue: 0,
        revenuePerDay: 0,
        numBookings: 0,
        noleggiati: 0,
        totalRevenueDays: 0
      };

      baseAggregates.forEach(b => {
        const idx = getMonthIndexGlobal(b.year, b.month);
        if (indicesSet.has(idx)) {
          res.fleetSize += b.fleetSize;
          res.canoneImponibile += b.canoneImponibile;
          res.canoneIvato += b.canoneIvato;
          res.assicurazione += b.assicurazione;
          res.costoTotale += b.costoTotale;
          res.revenue += b.revenue;
          res.numBookings += b.numBookings;
          res.noleggiati += b.noleggiati;
          res.totalRevenueDays += b.revenueDays || 0;
        }
      });

      if (res.totalRevenueDays > 0) {
        res.revenuePerDay = res.revenue / res.totalRevenueDays;
      } else {
        res.revenuePerDay = 0;
      }
      return res;
    }

    const currentIndicesSet = new Set();
    for (let i = minIdx; i <= maxIdx; i++) currentIndicesSet.add(i);

    const prevIndicesSet = new Set();
    for (let i = prevStartClamped; i <= prevEndClamped; i++) {
      if (i >= 0 && i < 36) prevIndicesSet.add(i);
    }

    const current = sumForIndices(currentIndicesSet);
    const prev = sumForIndices(prevIndicesSet);

    function setKpi(idCurrent, idPrev, idDiff, currVal, prevVal, options = {}) {
      const elCurr = document.getElementById(idCurrent);
      const elPrev = document.getElementById(idPrev);
      const elDiff = document.getElementById(idDiff);

      const isCurrency = options.currency === true;
      const decimals = options.decimals ?? 0;

      function formatNumber(v) {
        if (!isFinite(v)) return "â€“";
        if (isCurrency) {
          return (
            "â‚¬ " +
            v.toLocaleString("it-IT", {
              minimumFractionDigits: decimals,
              maximumFractionDigits: decimals
            })
          );
        }
        return v.toLocaleString("it-IT", {
          minimumFractionDigits: decimals,
          maximumFractionDigits: decimals
        });
      }

      elCurr.textContent = formatNumber(currVal);
      elPrev.textContent = prevVal && prevVal !== 0 ? formatNumber(prevVal) : "â€“";

      let diffPerc = null;
      if (prevVal && prevVal !== 0) {
        diffPerc = ((currVal - prevVal) / prevVal) * 100;
      }

      elDiff.classList.remove("positive", "negative", "neutral");
      if (diffPerc === null) {
        elDiff.textContent = "â†”ï¸Ž 0%";
        elDiff.classList.add("neutral");
      } else if (diffPerc > 0) {
        elDiff.textContent = "ðŸ“ˆ +" + diffPerc.toFixed(1) + "%";
        elDiff.classList.add("positive");
      } else if (diffPerc < 0) {
        elDiff.textContent = "ðŸ“‰ " + diffPerc.toFixed(1) + "%";
        elDiff.classList.add("negative");
      } else {
        elDiff.textContent = "â†”ï¸Ž 0%";
        elDiff.classList.add("neutral");
      }
    }

    const monthsCountCurrent = currentIndicesSet.size || 1;
    const monthsCountPrev = prevIndicesSet.size || 1;
    const fleetCurrAvg = current.fleetSize / monthsCountCurrent;
    const fleetPrevAvg = prev.fleetSize / monthsCountPrev;

    setKpi(
      "kpi-fleet-current",
      "kpi-fleet-prev",
      "kpi-fleet-diff",
      fleetCurrAvg,
      fleetPrevAvg,
      { currency: false, decimals: 1 }
    );

    setKpi(
      "kpi-canone-current",
      "kpi-canone-prev",
      "kpi-canone-diff",
      current.canoneImponibile,
      prev.canoneImponibile,
      { currency: true, decimals: 0 }
    );

    const elCanIvato = document.getElementById("kpi-canone-ivato-current");
    elCanIvato.textContent =
      current.canoneIvato > 0
        ? "â‚¬ " +
          current.canoneIvato.toLocaleString("it-IT", {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0
          })
        : "â€“";

    setKpi(
      "kpi-assicurazione-current",
      "kpi-assicurazione-prev",
      "kpi-assicurazione-diff",
      current.assicurazione,
      prev.assicurazione,
      { currency: true, decimals: 0 }
    );

    setKpi(
      "kpi-costo-current",
      "kpi-costo-prev",
      "kpi-costo-diff",
      current.costoTotale,
      prev.costoTotale,
      { currency: true, decimals: 0 }
    );

    setKpi(
      "kpi-revenue-current",
      "kpi-revenue-prev",
      "kpi-revenue-diff",
      current.revenue,
      prev.revenue,
      { currency: true, decimals: 0 }
    );

    setKpi(
      "kpi-revday-current",
      "kpi-revday-prev",
      "kpi-revday-diff",
      current.revenuePerDay,
      prev.revenuePerDay,
      { currency: true, decimals: 2 }
    );

    setKpi(
      "kpi-bookings-current",
      "kpi-bookings-prev",
      "kpi-bookings-diff",
      current.numBookings,
      prev.numBookings,
      { currency: false, decimals: 0 }
    );

    setKpi(
      "kpi-noleggiati-current",
      "kpi-noleggiati-prev",
      "kpi-noleggiati-diff",
      current.noleggiati,
      prev.noleggiati,
      { currency: false, decimals: 1 }
    );
  }

  function resetKpiDisplay() {
    const ids = [
      "kpi-fleet-current",
      "kpi-fleet-prev",
      "kpi-fleet-diff",
      "kpi-canone-current",
      "kpi-canone-prev",
      "kpi-canone-diff",
      "kpi-canone-ivato-current",
      "kpi-assicurazione-current",
      "kpi-assicurazione-prev",
      "kpi-assicurazione-diff",
      "kpi-costo-current",
      "kpi-costo-prev",
      "kpi-costo-diff",
      "kpi-revenue-current",
      "kpi-revenue-prev",
      "kpi-revenue-diff",
      "kpi-revday-current",
      "kpi-revday-prev",
      "kpi-revday-diff",
      "kpi-bookings-current",
      "kpi-bookings-prev",
      "kpi-bookings-diff",
      "kpi-noleggiati-current",
      "kpi-noleggiati-prev",
      "kpi-noleggiati-diff"
    ];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = "â€“";
      if (el.classList) {
        el.classList.remove("positive", "negative");
        el.classList.add("neutral");
      }
    });
  }

  // =========================
  // CHART
  // =========================
  function updateChart() {
    const ctx = document.getElementById("mainChart").getContext("2d");

    const labels = monthlyAggregates.map(b => b.label);
    const fleetSeries = monthlyAggregates.map(b => b.fleetSize);
    const costSeries = monthlyAggregates.map(b => b.costoTotale);
    const revenueSeries = monthlyAggregates.map(b => b.revenue);
    const noleggiatiSeries = monthlyAggregates.map(b => b.noleggiati);

    if (mainChart) {
      mainChart.destroy();
    }

    mainChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "Dimensione flotta",
            data: fleetSeries,
            yAxisID: "y",
            borderWidth: 2,
            tension: 0.3
          },
          {
            label: "Costo totale",
            data: costSeries,
            yAxisID: "y1",
            borderWidth: 2,
            tension: 0.3
          },
          {
            label: "Revenue",
            data: revenueSeries,
            yAxisID: "y1",
            borderWidth: 2,
            tension: 0.3
          },
          {
            label: "Noleggiati",
            data: noleggiatiSeries,
            yAxisID: "y",
            borderWidth: 2,
            tension: 0.3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: "index",
          intersect: false
        },
        stacked: false,
        scales: {
          x: {
            ticks: {
              color: "#e5e7eb",
              maxRotation: 0,
              autoSkip: true
            },
            grid: {
              color: "rgba(148, 163, 184, 0.15)"
            }
          },
          y: {
            type: "linear",
            position: "left",
            title: {
              display: true,
              text: "Flotta / Noleggiati",
              color: "#e5e7eb"
            },
            ticks: {
              color: "#e5e7eb"
            },
            grid: {
              color: "rgba(148, 163, 184, 0.15)"
            }
          },
          y1: {
            type: "linear",
            position: "right",
            title: {
              display: true,
              text: "â‚¬",
              color: "#e5e7eb"
            },
            ticks: {
              color: "#e5e7eb"
            },
            grid: {
              drawOnChartArea: false
            }
          }
        },
        plugins: {
          legend: {
            labels: {
              color: "#e5e7eb"
            }
          },
          tooltip: {
            callbacks: {
              footer: () => ""
            }
          }
        }
      }
    });
  }

  // =========================
  // EXPORT CSV
  // =========================
  function exportCsv() {
    if (!monthlyAggregates || monthlyAggregates.length === 0) {
      alert("Nessun dato da esportare.");
      return;
    }

    const header = [
      "Anno",
      "Mese",
      "Label",
      "FleetSize",
      "CanoneImponibile",
      "CanoneIvato",
      "Assicurazione",
      "CostoTotale",
      "Revenue",
      "RevenuePerDay",
      "NumBookings",
      "Noleggiati"
    ];

    const rows = monthlyAggregates.map(b => [
      b.year,
      b.month,
      b.label,
      b.fleetSize,
      b.canoneImponibile,
      b.canoneIvato,
      b.assicurazione,
      b.costoTotale,
      b.revenue,
      b.revenuePerDay,
      b.numBookings,
      b.noleggiati
    ]);

    let csvContent = header.join(";") + "\n";
    rows.forEach(r => {
      csvContent += r.join(";") + "\n";
    });

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "dashboard_fleet_bookings.csv";
    link.click();
    URL.revokeObjectURL(url);
  }
</script>
