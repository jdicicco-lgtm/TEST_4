<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard Flotta & Prenotazioni 2024‚Äì2026</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg-body: #020617;
      --bg-card: #0b1120;
      --bg-input: #020617;
      --border-input: #1f2937;
      --text-primary: #e5e7eb;
      --text-muted: #9ca3af;
    }

    body {
      background-color: var(--bg-body);
      color: var(--text-primary);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .card {
      background-color: var(--bg-card);
      color: var(--text-primary);
      border-radius: 1rem;
      border: 1px solid #111827;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
    }

    .card-header {
      border-bottom-color: #111827;
      background-color: transparent;
      color: var(--text-primary);
    }

    .kpi-card { height: 100%; }

    .kpi-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-muted);
      letter-spacing: 0.05em;
    }

    .kpi-value {
      font-size: 1.4rem;
      font-weight: 700;
    }

    .kpi-sub {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .kpi-delta {
      font-weight: 600;
      margin-left: 0.25rem;
    }

    .kpi-delta-positive { color: #22c55e; }
    .kpi-delta-negative { color: #ef4444; }
    .kpi-delta-neutral  { color: var(--text-muted); }

    .chart-card { height: 100%; }

    .filter-title-main {
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: var(--text-primary);
    }

    .filter-section-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      margin-top: 0.75rem;
      margin-bottom: 0.25rem;
    }

    .form-select {
      background-color: var(--bg-input);
      border-color: var(--border-input);
      color: var(--text-primary);
      font-size: 0.85rem;
    }

    .form-select:focus {
      border-color: #6366f1;
      box-shadow: 0 0 0 1px #6366f1;
      outline: none;
    }

    .filter-helper {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .btn-icon {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.8rem;
    }

    .btn-outline-secondary,
    .btn-outline-danger {
      border-radius: 999px;
    }

    @media print {
      body {
        background-color: #ffffff !important;
        color: #000000 !important;
      }

      .no-print { display: none !important; }

      .container-fluid {
        padding: 0 !important;
        margin: 0 !important;
      }

      .card {
        box-shadow: none !important;
        border-radius: 0 !important;
      }

      #mainChart { max-height: 400px; }
    }
  </style>
</head>
<body>
<div class="container-fluid py-3">
  <!-- HEADER -->
  <div class="d-flex flex-column flex-md-row justify-content-between align-items-md-center mb-3 gap-2">
    <div>
      <h1 class="h4 mb-1">Dashboard Flotta &amp; Prenotazioni 2024‚Äì2026</h1>
      <div class="small" style="color: var(--text-muted);">
        Analisi integrata <strong>flotta</strong> &amp; <strong>prenotazioni</strong> con proiezioni 2024‚Äì2026.
      </div>
    </div>
    <div class="btn-group no-print" role="group">
      <button id="btnCsv" type="button" class="btn btn-outline-secondary btn-sm btn-icon">
        üì• <span>Scarica CSV dati filtrati</span>
      </button>
      <button id="btnPrint" type="button" class="btn btn-outline-secondary btn-sm btn-icon">
        üñ®Ô∏è <span>Stampa / Esporta PDF</span>
      </button>
      <button id="btnReset" type="button" class="btn btn-outline-danger btn-sm btn-icon">
        ‚ôªÔ∏è <span>Pulisci filtri</span>
      </button>
    </div>
  </div>

  <div class="row g-3">
    <!-- FILTRI -->
    <div class="col-12 col-lg-3 no-print">
      <div class="card">
        <div class="card-header">
          <div class="filter-title-main text-uppercase">Filtri dashboard</div>
        </div>
        <div class="card-body">

          <!-- DATA -->
          <div class="filter-section-title">ANNO</div>
          <select id="filterYear" class="form-select form-select-sm" multiple></select>
          <div class="filter-helper mb-2">Seleziona uno o pi√π anni. Vuoto = tutti.</div>

          <div class="filter-section-title">MESE</div>
          <select id="filterMonth" class="form-select form-select-sm" multiple></select>
          <div class="filter-helper mb-2">Etichette in italiano. Vuoto = tutti.</div>

          <!-- TIPOLOGIA / GRUPPO -->
          <div class="filter-section-title">TIPOLOGIA</div>
          <select id="filterTipologia" class="form-select form-select-sm" multiple style="display:none;"></select>
          <div id="filterTipologiaHelper" class="filter-helper mb-2" style="display:none;">
            Se presente nei dati, filtra per tipologia/tipo.
          </div>

          <div class="filter-section-title">GRUPPO VEICOLO</div>
          <select id="filterGroup" class="form-select form-select-sm" multiple></select>
          <div class="filter-helper mb-2">Lista fissa dei 10 gruppi. Vuoto = tutti.</div>

          <!-- ACQ / STAZIONE -->
          <div class="filter-section-title">ACQUISIZIONE</div>
          <select id="filterAcquisition" class="form-select form-select-sm" multiple></select>
          <div class="filter-helper mb-2">Basato su campo <code>acquisizione</code> di flotta/prenotazioni.</div>

          <div class="filter-section-title">STAZIONE</div>
          <select id="filterStation" class="form-select form-select-sm" multiple></select>
          <div class="filter-helper mb-2">Stazioni normalizzate (niente duplicati per maiuscole/minuscole).</div>

          <!-- PROIEZIONE -->
          <div class="filter-section-title">PROIEZIONE 2026 üîÆ</div>
          <select id="filterProjection" class="form-select form-select-sm">
            <option value="0.05">5%</option>
            <option value="0.10" selected>10%</option>
            <option value="0.15">15%</option>
            <option value="0.20">20%</option>
          </select>
          <div class="filter-helper mb-0">
            Applica la percentuale alle proiezioni 2026 (Feb‚ÄìDic). Gennaio 2026 resta sempre reale.
          </div>
        </div>
      </div>
    </div>

    <!-- KPI + CHART -->
    <div class="col-12 col-lg-9">
      <!-- KPI ROW 1 -->
      <div class="row g-3 mb-2">
        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üöó Dimensione flotta (media)</div>
              <div class="kpi-value" id="kpiFleetSizeCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiFleetSizePrev">Prec.: --</span>
                <span id="kpiFleetSizeDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üí∂ Canone imponibile</div>
              <div class="kpi-value" id="kpiCanoneImponibileCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiCanoneImponibilePrev">Prec.: --</span>
                <span id="kpiCanoneImponibileDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
              <div class="kpi-sub">
                <span id="kpiCanoneIvatoInline">IVATO: --</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üí∂ Canone totale IVATO</div>
              <div class="kpi-value" id="kpiCanoneIvatoCurrent">--</div>
              <div class="kpi-sub">
                Somma del campo <code>CANONE IVATO</code> per tutti i mesi di attivazione flotta.
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üõ°Ô∏è Assicurazione</div>
              <div class="kpi-value" id="kpiAssicurazioneCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiAssicurazionePrev">Prec.: --</span>
                <span id="kpiAssicurazioneDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- KPI ROW 2 -->
      <div class="row g-3 mb-2">
        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üí∞ Costo totale (canone + ass.)</div>
              <div class="kpi-value" id="kpiCostoTotaleCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiCostoTotalePrev">Prec.: --</span>
                <span id="kpiCostoTotaleDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üí∏ Revenue</div>
              <div class="kpi-value" id="kpiRevenueCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiRevenuePrev">Prec.: --</span>
                <span id="kpiRevenueDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">‚òÄÔ∏è Revenue per day</div>
              <div class="kpi-value" id="kpiRevPerDayCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiRevPerDayPrev">Prec.: --</span>
                <span id="kpiRevPerDayDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üìù Numero prenotazioni</div>
              <div class="kpi-value" id="kpiNumPrenotazioniCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiNumPrenotazioniPrev">Prec.: --</span>
                <span id="kpiNumPrenotazioniDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- KPI ROW 3 -->
      <div class="row g-3 mb-3">
        <div class="col-12 col-md-6 col-xl-4">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">üöô Veicoli effettivamente noleggiati</div>
              <div class="kpi-value" id="kpiVeicoliNoleggiatiCurrent">--</div>
              <div class="kpi-sub">
                <span id="kpiVeicoliNoleggiatiPrev">Prec.: --</span>
                <span id="kpiVeicoliNoleggiatiDelta" class="kpi-delta kpi-delta-neutral">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-4">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">‚úÖ Prenotazioni effettive (Gennaio 2026)</div>
              <div class="kpi-value" id="kpiPrenotazioniGen2026Current">--</div>
              <div class="kpi-sub">
                Solo bookingsJan2026, filtrate per gruppo/acquisizione/stazione (senza proiezioni).
              </div>
            </div>
          </div>
        </div>

        <div class="col-12 col-md-6 col-xl-4">
          <div class="card kpi-card">
            <div class="card-body">
              <div class="kpi-title">‚ÑπÔ∏è Info KPI</div>
              <div class="kpi-sub">
                I confronti storici usano un periodo precedente con stessa ampiezza temporale (in mesi) spostato indietro rispetto al range selezionato.
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- CHART -->
      <div class="card chart-card">
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <div>
              <h2 class="h6 mb-0">Andamento mensile</h2>
              <div class="small" style="color: var(--text-muted);">
                Flotta, costi totali, revenue e veicoli effettivamente noleggiati su asse temporale Anno‚ÄìMese.
              </div>
            </div>
          </div>
          <canvas id="mainChart" height="120"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Bootstrap JS bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<script>
  /* ========= CONFIG & STATE ========= */

  const YEARS_AVAILABLE = [2024, 2025, 2026];
  const MONTH_LABELS_IT = [
    'Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno',
    'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'
  ];

  const VEHICLE_GROUPS = [
    'Commercial Van', 'Large', 'Economy', 'Small', 'Mini',
    'Premium', 'Suv', 'People Mover', 'Station Wagon', 'Cabriolet'
  ];

  function groupLabelToKey(label) {
    return label.toUpperCase().replace(/\s+/g, '_').trim();
  }

  let fleetRaw = [];
  let fleetStationsRaw = [];
  let bookings2025Raw = [];
  let bookingsJan2026Raw = [];

  let fleetNormalized = [];
  let bookings2025Normalized = [];
  let bookingsJan2026Normalized = [];
  let allBookingsWithProjections = [];

  let fleetColumnMap = {};
  let bookingColumnMap = {};
  let tipologiaColumnName = null;
  let tipologiaValues = [];

  let acquisitionsSet = new Set();
  let stationMap = new Map();   // key lowercase -> label

  let currentProjectionFactor = 0.10;
  let mainChart = null;

  let lastFilteredBookingsCurrent = [];

  /* ========= UTILS ========= */

  function parseNumber(val) {
    if (typeof val === 'number') return isFinite(val) ? val : 0;
    if (typeof val === 'string') {
      const cleaned = val.replace(/\./g, '').replace(',', '.').replace(/[^\d.-]/g, '');
      const n = parseFloat(cleaned);
      return isNaN(n) ? 0 : n;
    }
    return 0;
  }

  function parseDateFlexible(val) {
    if (val instanceof Date) return val;
    if (typeof val === 'number') return new Date(val);

    if (typeof val === 'string') {
      const t = val.trim();
      if (!t) return null;

      let d = new Date(t);
      if (!isNaN(d.getTime())) return d;

      let m = t.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
      if (m) {
        d = new Date(parseInt(m[3], 10), parseInt(m[2], 10) - 1, parseInt(m[1], 10));
        if (!isNaN(d.getTime())) return d;
      }

      m = t.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (m) {
        d = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
        if (!isNaN(d.getTime())) return d;
      }

      m = t.match(/^(\d{4})-(\d{2})$/);
      if (m) {
        d = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, 1);
        if (!isNaN(d.getTime())) return d;
      }

      m = t.match(/^(\d{4})(\d{2})(\d{2})$/);
      if (m) {
        d = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
        if (!isNaN(d.getTime())) return d;
      }

      m = t.match(/^(\d{4})(\d{2})$/);
      if (m) {
        d = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, 1);
        if (!isNaN(d.getTime())) return d;
      }
    }
    return null;
  }

  function ymToKey(year, month) {
    return `${year}-${String(month).padStart(2, '0')}`;
  }

  function shiftMonth(year, month, delta) {
    const d = new Date(year, month - 1 + delta, 1);
    return { year: d.getFullYear(), month: d.getMonth() + 1 };
  }

  function monthsDiff(startYear, startMonth, endYear, endMonth) {
    return (endYear - startYear) * 12 + (endMonth - startMonth);
  }

  function formatMoney(eur) {
    if (!isFinite(eur)) return '--';
    return eur.toLocaleString('it-IT', { style: 'currency', currency: 'EUR', maximumFractionDigits: 0 });
  }

  function formatMoney2(eur) {
    if (!isFinite(eur)) return '--';
    return eur.toLocaleString('it-IT', { style: 'currency', currency: 'EUR', maximumFractionDigits: 2 });
  }

  function formatNumberInt(n) {
    if (!isFinite(n)) return '--';
    return Math.round(n).toLocaleString('it-IT');
  }

  function formatDelta(current, previous) {
    if (!isFinite(previous) || previous === 0) return { text: '‚Äì', cssClass: 'kpi-delta-neutral' };
    if (!isFinite(current)) return { text: '‚Äì', cssClass: 'kpi-delta-neutral' };

    const diff = current - previous;
    const pct = (diff / Math.abs(previous)) * 100;
    if (!isFinite(pct)) return { text: '‚Äì', cssClass: 'kpi-delta-neutral' };

    const sign = pct > 0 ? '+' : (pct < 0 ? '‚àí' : '¬±');
    const absPct = Math.abs(pct).toFixed(1).replace('.', ',') + '%';

    let cssClass = 'kpi-delta-neutral';
    if (pct > 0.0001) cssClass = 'kpi-delta-positive';
    else if (pct < -0.0001) cssClass = 'kpi-delta-negative';

    return { text: `${sign}${absPct}`, cssClass };
  }

  function getMultiSelectValues(selectId) {
    const el = document.getElementById(selectId);
    if (!el) return [];
    return Array.from(el.selectedOptions)
      .map(o => o.value)
      .filter(v => v !== '');
  }

  /* ========= NORMALIZZAZIONE ========= */

  // confronto robusto: minuscolo + rimozione spazi, underscore, punti
  function findColumnName(row, candidates) {
    if (!row) return null;

    const normalize = s =>
      String(s)
        .toLowerCase()
        .replace(/[\s_.]/g, '');

    const map = {};
    Object.keys(row).forEach(k => {
      map[normalize(k)] = k;
    });

    for (const c of candidates) {
      const found = map[normalize(c)];
      if (found) return found;
    }
    return null;
  }

  function inferFleetColumns(fleetArray) {
    if (!fleetArray || fleetArray.length === 0) return;
    const sample = fleetArray[0];

    fleetColumnMap = {
      refDate: findColumnName(sample, [
        'refDate',
        'data',
        'date',
        'referenceDate',
        'dataRif',
        'ref_date',
        'data inizio',
        'dataInizio'
      ]),
      yearCol: findColumnName(sample, ['anno', 'year']),
      monthCol: findColumnName(sample, ['mese', 'month', 'mese_rif']),

      group: findColumnName(sample, [
        'gruppo',
        'group',
        'vehicleGroup',
        'carGroup',
        'gruppo_veicolo'
      ]),

      acquisition: findColumnName(sample, [
        'acquisizione',
        'acquisition',
        'tipo_acquisizione',
        'source'
      ]),

      station: findColumnName(sample, [
        'stazione',
        'station',
        'filiale',
        'location'
      ]),

      canoneImponibile: findColumnName(sample, [
        'canoneImponibile',
        'canone_imponibile',
        'canone imponibile',
        'canone',
        'canoneNetto'
      ]),

      canoneIvato: findColumnName(sample, [
        'canone ivato',
        'canoneIvato',
        'canone_ivato',
        'canone lordo'
      ]),

      assicurazione: findColumnName(sample, [
        'assicurazione',
        'insurance',
        'canoneAssicurazione',
        'canone_assicurazione',
        'copertura ass.',
        'copertura ass'
      ]),

      // date di fine
      endDateEff: findColumnName(sample, [
        'riconsegna effettiva',
        'data effettiva',
        'data riconsegna effettiva'
      ]),
      endDateFine: findColumnName(sample, [
        'data fine',
        'fine contratto',
        'data_fine'
      ]),

      tipologia: findColumnName(sample, [
        'tipologia',
        'tipo',
        'type',
        'categoria'
      ])
    };

    if (fleetColumnMap.tipologia) tipologiaColumnName = fleetColumnMap.tipologia;
  }

  function inferBookingColumns(bookingsArray) {
    if (!bookingsArray || bookingsArray.length === 0) return;
    const sample = bookingsArray[0];
    bookingColumnMap = {
      startDate: findColumnName(sample, ['startDate', 'from', 'DATA_INIZIO', 'dataInizio', 'data_inizio', 'date']),
      yearCol: findColumnName(sample, ['anno', 'year']),
      monthCol: findColumnName(sample, ['mese', 'month', 'mese_rif']),
      group: findColumnName(sample, ['gruppo', 'group', 'vehicleGroup', 'carType', 'car_group']),
      station: findColumnName(sample, ['stazione', 'station', 'filiale', 'location']),
      acquisition: findColumnName(sample, ['acquisizione', 'acquisition', 'tipo_acquisizione', 'source']),
      duration: findColumnName(sample, ['duration', 'giorni', 'days', 'n_giorni', 'durata']),
      price: findColumnName(sample, ['price', 'revenue', 'ricavo', 'importo', 'totale']),
      vehicleId: findColumnName(sample, ['targa', 'plate', 'vehicleId', 'idVeicolo', 'id_veicolo', 'veicolo'])
    };
  }

  function normalizeStation(raw) {
    if (!raw && raw !== 0) return { label: null, key: null };
    const label = String(raw).trim();
    if (!label) return { label: null, key: null };
    const key = label.toLowerCase();
    if (!stationMap.has(key)) stationMap.set(key, label);
    return { label, key };
  }

  function normalizeAcquisition(raw) {
    if (raw === null || raw === undefined) return '';
    if (typeof raw === 'number') {
      if (!isFinite(raw)) return '';
      return String(raw);
    }
    const s = String(raw).trim();
    if (!s) return '';
    if (/^nan$/i.test(s)) return '';
    return s;
  }

 function normalizeGroup(raw) {
  if (!raw && raw !== 0) return null;

  let s = String(raw).trim().toLowerCase();

  // normalizzazioni di base
  // üëâ VAN ora √® considerato COMMERCIAL VAN
  if (s === 'furgone' || s === 'furgoni' || s === 'van') s = 'commercial van';
  if (s === 'people mover' || s === 'peoplemover' || s === 'pm') s = 'people mover';

  // se combacia esattamente con una delle label "ufficiali"
  for (const label of VEHICLE_GROUPS) {
    if (s === label.toLowerCase()) {
      return { label, key: groupLabelToKey(label) };
    }
  }

  // euristiche:
  // COMMERCIAL VAN
  if (
    s.includes('commercial') ||
    s.includes('furgon') ||         // "furgone", "furgoni"
    s.includes('van comm')         // "van commerciale"
  ) {
    const label = 'Commercial Van';
    return { label, key: groupLabelToKey(label) };
  }

  // PEOPLE MOVER
  if (s.includes('people')) {
    const label = 'People Mover';
    return { label, key: groupLabelToKey(label) };
  }

  // altre categorie
  if (s.includes('station')) {
    const label = 'Station Wagon';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('cabrio')) {
    const label = 'Cabriolet';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('suv')) {
    const label = 'Suv';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('premium')) {
    const label = 'Premium';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('mini')) {
    const label = 'Mini';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('small')) {
    const label = 'Small';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('economy')) {
    const label = 'Economy';
    return { label, key: groupLabelToKey(label) };
  }
  if (s.includes('large')) {
    const label = 'Large';
    return { label, key: groupLabelToKey(label) };
  }

  return null;
}


  function normalizeFleetRow(row) {
    // DATA INIZIO
    let startDate = null;

    if (fleetColumnMap.refDate) {
      startDate = parseDateFlexible(row[fleetColumnMap.refDate]);
    }

    if (!startDate && fleetColumnMap.yearCol && fleetColumnMap.monthCol) {
      const y = parseInt(row[fleetColumnMap.yearCol], 10);
      const m = parseInt(row[fleetColumnMap.monthCol], 10);
      if (!isNaN(y) && !isNaN(m) && m >= 1 && m <= 12) {
        startDate = new Date(y, m - 1, 1);
      }
    }

    if (!startDate) return null;

    // DATA FINE: prima RICONSEGNA EFFETTIVA / DATA EFFETTIVA, poi DATA FINE
    let endEff = null;
    let endFine = null;

    if (fleetColumnMap.endDateEff) {
      endEff = parseDateFlexible(row[fleetColumnMap.endDateEff]);
    }
    if (fleetColumnMap.endDateFine) {
      endFine = parseDateFlexible(row[fleetColumnMap.endDateFine]);
    }

    let endDate = endEff || endFine || startDate;

    // se per errore endDate < startDate, forziamo almeno lo stesso mese
    if (endDate < startDate) endDate = startDate;

    const groupInfo = normalizeGroup(row[fleetColumnMap.group]);
    const acquisition = normalizeAcquisition(fleetColumnMap.acquisition ? row[fleetColumnMap.acquisition] : '');
    const stationRaw = fleetColumnMap.station ? row[fleetColumnMap.station] : '';
    const stationInfo = normalizeStation(stationRaw);

    const canoneImponibile = fleetColumnMap.canoneImponibile ? parseNumber(row[fleetColumnMap.canoneImponibile]) : 0;
    const canoneIvato = fleetColumnMap.canoneIvato ? parseNumber(row[fleetColumnMap.canoneIvato]) : 0;
    const assicurazione = fleetColumnMap.assicurazione ? parseNumber(row[fleetColumnMap.assicurazione]) : 0;

    let tipologia = null;
    if (tipologiaColumnName) {
      tipologia = String(row[tipologiaColumnName] ?? '').trim() || null;
      if (tipologia) tipologiaValues.push(tipologia);
    }

    if (acquisition) acquisitionsSet.add(acquisition);

    return {
      raw: row,
      startDate,
      endDate,
      groupLabel: groupInfo ? groupInfo.label : null,
      groupKey: groupInfo ? groupInfo.key : null,
      acquisition,
      stationLabel: stationInfo.label,
      stationKey: stationInfo.key,
      canoneImponibile,
      canoneIvato,
      assicurazione,
      tipologia
    };
  }

  function normalizeBookingRow(row, isJan2026Real) {
    let d = null;

    if (bookingColumnMap.startDate) {
      d = parseDateFlexible(row[bookingColumnMap.startDate]);
    }

    if (!d && bookingColumnMap.yearCol && bookingColumnMap.monthCol) {
      const y = parseInt(row[bookingColumnMap.yearCol], 10);
      const m = parseInt(row[bookingColumnMap.monthCol], 10);
      if (!isNaN(y) && !isNaN(m) && m >= 1 && m <= 12) {
        d = new Date(y, m - 1, 1);
      }
    }

    if (!d) return null;

    const year = d.getFullYear();
    const month = d.getMonth() + 1;

    const groupInfo = normalizeGroup(row[bookingColumnMap.group]);
    const stationRaw = bookingColumnMap.station ? row[bookingColumnMap.station] : '';
    const stationInfo = normalizeStation(stationRaw);
    const acquisition = normalizeAcquisition(bookingColumnMap.acquisition ? row[bookingColumnMap.acquisition] : '');
    const duration = bookingColumnMap.duration ? parseNumber(row[bookingColumnMap.duration]) : 0;
    const price = bookingColumnMap.price ? parseNumber(row[bookingColumnMap.price]) : 0;
    const vehicleId = bookingColumnMap.vehicleId ? String(row[bookingColumnMap.vehicleId] ?? '').trim() : null;

    if (acquisition) acquisitionsSet.add(acquisition);

    return {
      raw: row,
      date: d,
      year,
      month,
      groupLabel: groupInfo ? groupInfo.label : null,
      groupKey: groupInfo ? groupInfo.key : null,
      stationLabel: stationInfo.label,
      stationKey: stationInfo.key,
      acquisition,
      duration,
      price,
      vehicleId,
      isRealJan2026: !!isJan2026Real,
      source: isJan2026Real ? 'realJan2026' : 'real2025'
    };
  }

  /* ========= PROIEZIONI BOOKING ========= */

  function generateAllBookings(projectionFactor) {
    const result = [];

    for (const b of bookings2025Normalized) {
      result.push({ ...b, sourceYear: 2025, source: 'real2025' });

      const d2024 = new Date(b.date);
      d2024.setFullYear(2024);
      result.push({
        ...b,
        date: d2024,
        year: 2024,
        month: d2024.getMonth() + 1,
        price: b.price * 0.95,
        isRealJan2026: false,
        sourceYear: 2024,
        source: 'proj2024'
      });

      if (b.month !== 1) {
        const d2026 = new Date(b.date);
        d2026.setFullYear(2026);
        result.push({
          ...b,
          date: d2026,
          year: 2026,
          month: d2026.getMonth() + 1,
          price: b.price * (1 + projectionFactor),
          isRealJan2026: false,
          sourceYear: 2026,
          source: 'proj2026'
        });
      }
    }

    for (const b of bookingsJan2026Normalized) {
      const clone = { ...b, sourceYear: 2026, source: 'realJan2026' };
      result.push(clone);
    }

    allBookingsWithProjections = result;
  }

  /* ========= FILTRI & RANGE ========= */

  function readFilters() {
    const years = getMultiSelectValues('filterYear').map(v => parseInt(v, 10)).filter(v => !isNaN(v));
    const months = getMultiSelectValues('filterMonth').map(v => parseInt(v, 10)).filter(v => !isNaN(v));
    const groups = getMultiSelectValues('filterGroup');
    const acquisitions = getMultiSelectValues('filterAcquisition');
    const stations = getMultiSelectValues('filterStation');
    const tipologie = tipologiaColumnName ? getMultiSelectValues('filterTipologia') : [];
    return { years, months, groups, acquisitions, stations, tipologie };
  }

  function getCurrentAndPreviousRanges(filters) {
    const years = filters.years.length ? filters.years : YEARS_AVAILABLE.slice();
    const months = filters.months.length ? filters.months : Array.from({ length: 12 }, (_, i) => i + 1);

    const minYear = Math.min(...years);
    const maxYear = Math.max(...years);
    const minMonth = Math.min(...months);
    const maxMonth = Math.max(...months);

    const startCurrent = { year: minYear, month: minMonth };
    const endCurrent = { year: maxYear, month: maxMonth };

    const monthsCount = monthsDiff(startCurrent.year, startCurrent.month, endCurrent.year, endCurrent.month) + 1;

    const prevEnd = shiftMonth(startCurrent.year, startCurrent.month, -1);
    const prevStart = shiftMonth(prevEnd.year, prevEnd.month, -(monthsCount - 1));

    const currentRange = {
      startDate: new Date(startCurrent.year, startCurrent.month - 1, 1),
      endDate: new Date(endCurrent.year, endCurrent.month, 0),
      monthsCount,
      startYM: startCurrent,
      endYM: endCurrent
    };

    const previousRange = {
      startDate: new Date(prevStart.year, prevStart.month - 1, 1),
      endDate: new Date(prevEnd.year, prevEnd.month, 0),
      monthsCount,
      startYM: prevStart,
      endYM: prevEnd
    };

    return { current: currentRange, previous: previousRange };
  }

  function fleetRowMatchesFilters(row, filters) {
    if (filters.groups.length && row.groupKey && !filters.groups.includes(row.groupKey)) return false;
    if (filters.acquisitions.length) {
      if (!row.acquisition || !filters.acquisitions.includes(row.acquisition)) return false;
    }
    if (filters.stations.length) {
      if (!row.stationKey || !filters.stations.includes(row.stationKey)) return false;
    }
    if (tipologiaColumnName && filters.tipologie.length) {
      if (!row.tipologia || !filters.tipologie.includes(row.tipologia)) return false;
    }
    return true;
  }

  function bookingRowMatchesFilters(row, filters, isPreviousRange) {
    if (!isPreviousRange) {
      if (filters.years.length && !filters.years.includes(row.year)) return false;
      if (filters.months.length && !filters.months.includes(row.month)) return false;
    }
    if (filters.groups.length && row.groupKey && !filters.groups.includes(row.groupKey)) return false;
    if (filters.acquisitions.length) {
      if (!row.acquisition || !filters.acquisitions.includes(row.acquisition)) return false;
    }
    if (filters.stations.length) {
      if (!row.stationKey || !filters.stations.includes(row.stationKey)) return false;
    }
    return true;
  }

  function filterFleetForRange(range, filters) {
    return fleetNormalized.filter(row => {
      // intervallo attivo che interseca il range
      if (row.endDate < range.startDate || row.startDate > range.endDate) return false;
      return fleetRowMatchesFilters(row, filters);
    });
  }

  function filterBookingsForRange(range, filters, isPreviousRange) {
    return allBookingsWithProjections.filter(row => {
      if (row.date < range.startDate || row.date > range.endDate) return false;
      return bookingRowMatchesFilters(row, filters, isPreviousRange);
    });
  }

  /* ========= AGGREGAZIONI ========= */

  function buildMonthlyAggregates(range, fleetRows, bookingRows) {
    const agg = {};
    let curYear = range.startYM.year;
    let curMonth = range.startYM.month;

    // inizializza tutti i mesi del range
    for (let i = 0; i < range.monthsCount; i++) {
      const key = ymToKey(curYear, curMonth);
      agg[key] = {
        year: curYear,
        month: curMonth,
        fleetCount: 0,
        canoneImponibile: 0,
        canoneIvato: 0,
        assicurazione: 0,
        totalCost: 0,
        revenue: 0,
        totalDuration: 0,
        vehicleIds: new Set()
      };
      const next = shiftMonth(curYear, curMonth, 1);
      curYear = next.year;
      curMonth = next.month;
    }

    // flotta: veicolo attivo per TUTTI i mesi tra startDate e endDate
    for (const row of fleetRows) {
      const activeStart = row.startDate > range.startDate ? row.startDate : range.startDate;
      const activeEnd = row.endDate < range.endDate ? row.endDate : range.endDate;
      if (activeStart > activeEnd) continue;

      let y = activeStart.getFullYear();
      let m = activeStart.getMonth() + 1;
      const endY = activeEnd.getFullYear();
      const endM = activeEnd.getMonth() + 1;

      while (y < endY || (y === endY && m <= endM)) {
        const key = ymToKey(y, m);
        const slot = agg[key];
        if (slot) {
          slot.fleetCount += 1;
          slot.canoneImponibile += row.canoneImponibile;
          slot.canoneIvato += row.canoneIvato;
          slot.assicurazione += row.assicurazione;
          slot.totalCost += row.canoneImponibile + row.assicurazione;
        }
        if (y === endY && m === endM) break;
        const next = shiftMonth(y, m, 1);
        y = next.year;
        m = next.month;
      }
    }

    // booking
    for (const row of bookingRows) {
      const key = ymToKey(row.year, row.month);
      const slot = agg[key];
      if (!slot) continue;
      slot.revenue += row.price;
      slot.totalDuration += row.duration;
      const id = row.vehicleId || `booking_${row.source}_${row.year}_${row.month}_${Math.random().toString(36).slice(2)}`;
      slot.vehicleIds.add(id);
    }

    return agg;
  }

  function computeKpisFromAggregates(aggregates, bookingRows) {
    const entries = Object.values(aggregates);

    let fleetCountSum = 0;
    let fleetMonthsWithData = 0;
    let sumCanoneImponibile = 0;
    let sumCanoneIvato = 0;
    let sumAssicurazione = 0;
    let sumCost = 0;
    let sumRevenue = 0;
    let sumDuration = 0;
    const vehicleSet = new Set();

    for (const slot of entries) {
      if (slot.fleetCount > 0) {
        fleetCountSum += slot.fleetCount;
        fleetMonthsWithData += 1;
      }
      sumCanoneImponibile += slot.canoneImponibile;
      sumCanoneIvato += slot.canoneIvato;
      sumAssicurazione += slot.assicurazione;
      sumCost += slot.totalCost;
      sumRevenue += slot.revenue;
      sumDuration += slot.totalDuration;
      for (const id of slot.vehicleIds) vehicleSet.add(id);
    }

    const avgFleetSize = fleetMonthsWithData > 0 ? fleetCountSum / fleetMonthsWithData : 0;
    const revenuePerDay = sumDuration > 0 ? sumRevenue / sumDuration : 0;
    const numBookings = bookingRows.length;
    const numVehiclesRented = vehicleSet.size;

    return {
      avgFleetSize,
      sumCanoneImponibile,
      sumCanoneIvato,
      sumAssicurazione,
      sumCost,
      sumRevenue,
      revenuePerDay,
      numBookings,
      numVehiclesRented
    };
  }

  function computePrenotazioniEffettiveGen2026(filters) {
    let count = 0;
    for (const b of bookingsJan2026Normalized) {
      if (!bookingRowMatchesFilters(
        b,
        { years: [], months: [], groups: filters.groups, acquisitions: filters.acquisitions, stations: filters.stations, tipologie: [] },
        false
      )) continue;
      count += 1;
    }
    return count;
  }

  /* ========= CHART ========= */

  function updateChart(range, fleetRows, bookingRows) {
    const aggregates = buildMonthlyAggregates(range, fleetRows, bookingRows);
    const slots = Object.values(aggregates).sort((a, b) =>
      a.year === b.year ? a.month - b.month : a.year - b.year
    );

    const labels = slots.map(slot => {
      const mLabel = MONTH_LABELS_IT[slot.month - 1].slice(0, 3);
      return `${mLabel} ${slot.year}`;
    });

    const fleetData = slots.map(slot => slot.fleetCount);
    const costData = slots.map(slot => slot.totalCost);
    const revenueData = slots.map(slot => slot.revenue);
    const vehiclesRentedData = slots.map(slot => slot.vehicleIds.size);

    const ctx = document.getElementById('mainChart').getContext('2d');

    if (mainChart) {
      mainChart.data.labels = labels;
      mainChart.data.datasets[0].data = fleetData;
      mainChart.data.datasets[1].data = costData;
      mainChart.data.datasets[2].data = revenueData;
      mainChart.data.datasets[3].data = vehiclesRentedData;
      mainChart.update();
      return;
    }

    mainChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: 'Flotta (veicoli)',
            data: fleetData,
            yAxisID: 'yFleet',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 2
          },
          {
            label: 'Costo totale (‚Ç¨)',
            data: costData,
            yAxisID: 'yMoney',
            tension: 0.3,
            borderWidth: 1.8,
            borderDash: [4, 3],
            pointRadius: 2
          },
          {
            label: 'Revenue (‚Ç¨)',
            data: revenueData,
            yAxisID: 'yMoney',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 2
          },
          {
            label: 'Veicoli noleggiati',
            data: vehiclesRentedData,
            yAxisID: 'yFleet',
            tension: 0.3,
            borderWidth: 1.5,
            borderDash: [2, 2],
            pointRadius: 2
          }
        ]
      },
      options: {
        responsive: true,
        interaction: { mode: 'index', intersect: false },
        stacked: false,
        plugins: {
          legend: { position: 'top' },
          tooltip: {
            callbacks: {
              label: function (context) {
                const label = context.dataset.label || '';
                const value = context.parsed.y;
                if (label.includes('Flotta')) return `${label}: ${formatNumberInt(value)} veicoli`;
                if (label.includes('Costo totale')) return `${label}: ${formatMoney(value)}`;
                if (label.includes('Revenue')) return `${label}: ${formatMoney(value)}`;
                if (label.includes('Veicoli noleggiati')) return `${label}: ${formatNumberInt(value)}`;
                return `${label}: ${value}`;
              }
            }
          }
        },
        scales: {
          yFleet: {
            type: 'linear',
            position: 'left',
            title: { display: true, text: 'Veicoli' }
          },
          yMoney: {
            type: 'linear',
            position: 'right',
            title: { display: true, text: 'Euro' },
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
  }

  /* ========= KPI ========= */

  function updateKpiCard(current, previous, currentFormatter, prevFormatter, kpiCurrentId, kpiPrevId, kpiDeltaId) {
    const currentVal = current ?? 0;
    const prevVal = previous ?? 0;

    document.getElementById(kpiCurrentId).textContent = currentFormatter(currentVal);
    document.getElementById(kpiPrevId).textContent = 'Prec.: ' + prevFormatter(prevVal);

    const deltaInfo = formatDelta(currentVal, prevVal);
    const deltaEl = document.getElementById(kpiDeltaId);
    deltaEl.textContent = deltaInfo.text;
    deltaEl.className = 'kpi-delta ' + deltaInfo.cssClass;
  }

  function updateAllKpis(rangeCurrent, rangePrevious, fleetCurrent, fleetPrevious, bookingsCurrent, bookingsPrevious, filters) {
    const aggCurrent = buildMonthlyAggregates(rangeCurrent, fleetCurrent, bookingsCurrent);
    const aggPrevious = buildMonthlyAggregates(rangePrevious, fleetPrevious, bookingsPrevious);

    const kpiCurrent = computeKpisFromAggregates(aggCurrent, bookingsCurrent);
    const kpiPrevious = computeKpisFromAggregates(aggPrevious, bookingsPrevious);

    updateKpiCard(
      kpiCurrent.avgFleetSize,
      kpiPrevious.avgFleetSize,
      v => formatNumberInt(v),
      v => formatNumberInt(v),
      'kpiFleetSizeCurrent',
      'kpiFleetSizePrev',
      'kpiFleetSizeDelta'
    );

    updateKpiCard(
      kpiCurrent.sumCanoneImponibile,
      kpiPrevious.sumCanoneImponibile,
      v => formatMoney(v),
      v => formatMoney(v),
      'kpiCanoneImponibileCurrent',
      'kpiCanoneImponibilePrev',
      'kpiCanoneImponibileDelta'
    );

    // canone IVATO: usiamo il valore reale e lo mostriamo inline sotto il canone imponibile
    document.getElementById('kpiCanoneIvatoCurrent').textContent = formatMoney(kpiCurrent.sumCanoneIvato);
    document.getElementById('kpiCanoneIvatoInline').textContent = 'IVATO: ' + formatMoney(kpiCurrent.sumCanoneIvato);

    updateKpiCard(
      kpiCurrent.sumAssicurazione,
      kpiPrevious.sumAssicurazione,
      v => formatMoney(v),
      v => formatMoney(v),
      'kpiAssicurazioneCurrent',
      'kpiAssicurazionePrev',
      'kpiAssicurazioneDelta'
    );

    updateKpiCard(
      kpiCurrent.sumCost,
      kpiPrevious.sumCost,
      v => formatMoney(v),
      v => formatMoney(v),
      'kpiCostoTotaleCurrent',
      'kpiCostoTotalePrev',
      'kpiCostoTotaleDelta'
    );

    updateKpiCard(
      kpiCurrent.sumRevenue,
      kpiPrevious.sumRevenue,
      v => formatMoney(v),
      v => formatMoney(v),
      'kpiRevenueCurrent',
      'kpiRevenuePrev',
      'kpiRevenueDelta'
    );

    updateKpiCard(
      kpiCurrent.revenuePerDay,
      kpiPrevious.revenuePerDay,
      v => formatMoney2(v),
      v => formatMoney2(v),
      'kpiRevPerDayCurrent',
      'kpiRevPerDayPrev',
      'kpiRevPerDayDelta'
    );

    updateKpiCard(
      kpiCurrent.numBookings,
      kpiPrevious.numBookings,
      v => formatNumberInt(v),
      v => formatNumberInt(v),
      'kpiNumPrenotazioniCurrent',
      'kpiNumPrenotazioniPrev',
      'kpiNumPrenotazioniDelta'
    );

    updateKpiCard(
      kpiCurrent.numVehiclesRented,
      kpiPrevious.numVehiclesRented,
      v => formatNumberInt(v),
      v => formatNumberInt(v),
      'kpiVeicoliNoleggiatiCurrent',
      'kpiVeicoliNoleggiatiPrev',
      'kpiVeicoliNoleggiatiDelta'
    );

    const prenGen2026 = computePrenotazioniEffettiveGen2026(filters);
    document.getElementById('kpiPrenotazioniGen2026Current').textContent = formatNumberInt(prenGen2026);
  }

  /* ========= CSV EXPORT ========= */

  function downloadCsvFilteredData() {
    const rows = lastFilteredBookingsCurrent || [];
    const header = ['Data', 'Anno', 'Mese', 'Gruppo', 'Stazione', 'Acquisizione', 'Duration', 'Price'];
    const lines = [header.join(';')];

    for (const b of rows) {
      const d = b.date;
      const dateStr = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
      const line = [
        dateStr,
        b.year,
        b.month,
        b.groupLabel || '',
        (b.stationLabel || '').replace(/;/g, ','),
        (b.acquisition || '').replace(/;/g, ','),
        b.duration,
        b.price.toString().replace('.', ',')
      ].join(';');
      lines.push(line);
    }

    const csvStr = lines.join('\n');
    const blob = new Blob([csvStr], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'dashboard_dati_filtrati.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  /* ========= MAIN UPDATE ========= */

  function updateDashboard() {
    const filters = readFilters();
    const ranges = getCurrentAndPreviousRanges(filters);

    const fleetCurrent = filterFleetForRange(ranges.current, filters);
    const fleetPrevious = filterFleetForRange(ranges.previous, filters);

    const bookingsCurrent = filterBookingsForRange(ranges.current, filters, false);
    const bookingsPrevious = filterBookingsForRange(ranges.previous, filters, true);

    lastFilteredBookingsCurrent = bookingsCurrent;

    updateAllKpis(
      ranges.current,
      ranges.previous,
      fleetCurrent,
      fleetPrevious,
      bookingsCurrent,
      bookingsPrevious,
      filters
    );
    updateChart(ranges.current, fleetCurrent, bookingsCurrent);
  }

  /* ========= FILTRI UI ========= */

  function addPlaceholderOption(selectEl, label) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = label;
    opt.selected = true;
    selectEl.appendChild(opt);
  }

  function setupMultiSelectBehaviour(selectId) {
    const el = document.getElementById(selectId);
    if (!el) return;
    el.addEventListener('change', () => {
      const options = Array.from(el.options);
      const realSelected = options.filter(o => o.selected && o.value !== '');
      const allOption = options.find(o => o.value === '');
      if (realSelected.length > 0 && allOption && allOption.selected) {
        allOption.selected = false;
      }
      if (realSelected.length === 0 && allOption) {
        allOption.selected = true;
      }
      updateDashboard();
    });
  }

  function populateFilterOptions() {
    // ANNO
    const yearSelect = document.getElementById('filterYear');
    yearSelect.innerHTML = '';
    addPlaceholderOption(yearSelect, 'Tutti');
    YEARS_AVAILABLE.forEach(y => {
      const opt = document.createElement('option');
      opt.value = String(y);
      opt.textContent = String(y);
      yearSelect.appendChild(opt);
    });

    // MESE
    const monthSelect = document.getElementById('filterMonth');
    monthSelect.innerHTML = '';
    addPlaceholderOption(monthSelect, 'Tutti');
    for (let i = 0; i < 12; i++) {
      const opt = document.createElement('option');
      opt.value = String(i + 1);
      opt.textContent = MONTH_LABELS_IT[i];
      monthSelect.appendChild(opt);
    }

    // GRUPPO
    const groupSelect = document.getElementById('filterGroup');
    groupSelect.innerHTML = '';
    addPlaceholderOption(groupSelect, 'Tutti');
    for (const label of VEHICLE_GROUPS) {
      const opt = document.createElement('option');
      opt.value = groupLabelToKey(label);
      opt.textContent = label;
      groupSelect.appendChild(opt);
    }

    // ACQUISIZIONE
    const acqSelect = document.getElementById('filterAcquisition');
    acqSelect.innerHTML = '';
    addPlaceholderOption(acqSelect, 'Tutte');
    const acqList = Array.from(acquisitionsSet).filter(x => x).sort((a, b) => a.localeCompare(b));
    for (const a of acqList) {
      const opt = document.createElement('option');
      opt.value = a;
      opt.textContent = a;
      acqSelect.appendChild(opt);
    }

    // STAZIONE
    const stationSelect = document.getElementById('filterStation');
    stationSelect.innerHTML = '';
    addPlaceholderOption(stationSelect, 'Tutte');
    const stationEntries = Array.from(stationMap.entries()).sort((a, b) => a[1].localeCompare(b[1]));
    for (const [key, label] of stationEntries) {
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = label;
      stationSelect.appendChild(opt);
    }

    // TIPOLOGIA se presente
    if (tipologiaColumnName && tipologiaValues.length) {
      const tipSelect = document.getElementById('filterTipologia');
      const tipHelper = document.getElementById('filterTipologiaHelper');
      tipSelect.innerHTML = '';
      addPlaceholderOption(tipSelect, 'Tutte');
      const uniqueTips = Array.from(new Set(tipologiaValues.filter(x => x))).sort((a, b) => a.localeCompare(b));
      for (const t of uniqueTips) {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        tipSelect.appendChild(opt);
      }
      tipSelect.style.display = '';
      tipHelper.style.display = '';
      setupMultiSelectBehaviour('filterTipologia');
    } else {
      document.getElementById('filterTipologia').style.display = 'none';
      document.getElementById('filterTipologiaHelper').style.display = 'none';
    }

    setupMultiSelectBehaviour('filterYear');
    setupMultiSelectBehaviour('filterMonth');
    setupMultiSelectBehaviour('filterGroup');
    setupMultiSelectBehaviour('filterAcquisition');
    setupMultiSelectBehaviour('filterStation');
  }

  function attachExtraListeners() {
    document.getElementById('filterProjection').addEventListener('change', () => {
      const val = parseFloat(document.getElementById('filterProjection').value);
      if (!isNaN(val)) {
        currentProjectionFactor = val;
        generateAllBookings(currentProjectionFactor);
        updateDashboard();
      }
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      currentProjectionFactor = 0.10;
      document.getElementById('filterProjection').value = '0.10';
      generateAllBookings(currentProjectionFactor);

      const selectIds = ['filterYear', 'filterMonth', 'filterGroup', 'filterAcquisition', 'filterStation', 'filterTipologia'];
      selectIds.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const options = Array.from(el.options);
        options.forEach(o => (o.selected = false));
        const allOpt = options.find(o => o.value === '');
        if (allOpt) allOpt.selected = true;
      });

      updateDashboard();
    });

    document.getElementById('btnCsv').addEventListener('click', downloadCsvFilteredData);
    document.getElementById('btnPrint').addEventListener('click', () => window.print());
  }

  /* ========= DATA LOADING ========= */

  async function loadJson(path) {
    const response = await fetch(path);
    if (!response.ok) {
      throw new Error(`Errore nel caricamento di ${path}: ${response.status}`);
    }

    const text = await response.text();
    if (!text.trim()) {
      throw new Error(`Il file ${path} √® vuoto o non contiene JSON.`);
    }

    try {
      return JSON.parse(text);
    } catch (e) {
      console.error(`Errore nel parsing di ${path}`, e, 'Primi caratteri:', text.slice(0, 200));
      throw new Error(`Impossibile leggere ${path}. Controlla che sia un JSON valido.`);
    }
  }

  async function initDashboard() {
    try {
      const [
        fleetData,
        fleetStations,
        bookings2025,
        bookingsJan2026
      ] = await Promise.all([
        loadJson('fleetData_clean.json'),
        loadJson('fleetStations2025.json'),
        loadJson('bookings2025.json'),
        loadJson('bookingsJan2026.json')
      ]);

      fleetRaw = Array.isArray(fleetData) ? fleetData : [];
      fleetStationsRaw = Array.isArray(fleetStations) ? fleetStations : [];
      bookings2025Raw = Array.isArray(bookings2025) ? bookings2025 : [];
      bookingsJan2026Raw = Array.isArray(bookingsJan2026) ? bookingsJan2026 : [];

      inferFleetColumns(fleetRaw);
      inferBookingColumns(bookings2025Raw.length ? bookings2025Raw : bookingsJan2026Raw);

      fleetNormalized = [];
      tipologiaValues = [];
      acquisitionsSet = new Set();
      stationMap = new Map();

      for (const row of fleetRaw) {
        const norm = normalizeFleetRow(row);
        if (norm) fleetNormalized.push(norm);
      }

      if (fleetStationsRaw.length) {
        const sampleStation = fleetStationsRaw[0];
        const stationKeyName = findColumnName(sampleStation, ['stazione', 'station', 'filiale', 'location']);
        if (stationKeyName) {
          for (const row of fleetStationsRaw) {
            normalizeStation(row[stationKeyName]);
          }
        }
      }

      bookings2025Normalized = [];
      for (const row of bookings2025Raw) {
        const norm = normalizeBookingRow(row, false);
        if (norm) bookings2025Normalized.push(norm);
      }

      bookingsJan2026Normalized = [];
      for (const row of bookingsJan2026Raw) {
        const norm = normalizeBookingRow(row, true);
        if (norm) {
          norm.date.setFullYear(2026);
          norm.date.setMonth(0);
          norm.year = 2026;
          norm.month = 1;
          norm.isRealJan2026 = true;
          bookingsJan2026Normalized.push(norm);
        }
      }

      generateAllBookings(currentProjectionFactor);

      populateFilterOptions();
      attachExtraListeners();
      updateDashboard();
    } catch (err) {
      console.error(err);
      alert(err.message);
    }
  }

  document.addEventListener('DOMContentLoaded', initDashboard);
</script>
</body>
</html>
